
# Little Endian과 Big Endian

## 메모리 표현식
- 숫자: 16
- 16진수: 0x00000010
- BE: 00 00 00 10
- LE: 10 00 00 00

CPU 아키텍처에 따라 메모리에 올리는 방식이 달라진다.
메모리에 올라간 값이 다르기 때문에 연산을 할 때도 서로 다른 방식으로 연산을 한다.

---

## BE 과 LE간 변환
사용하는 메모리 범위안에서 순서를 뒤집으면 된다.

### 1바이트
- BE: 12
- LE: 12

### 2바이트
- BE: 12 34
- LE: 34 12

### 4바이트
- BE: 12 34 56 78
- LE: 78 56 34 12

### 8바이트
- BE: 12 34 56 78 9A BC DE EF
- LE: EF DE BD 9A 78 56 34 12

### 16바이트 (x)
- 12 34 56 78 9A BC DE EF EF DE BC 9A 78 56 34 12

64비트 CPU에서는 최대 8바이트에 대한 연산만 지원하기 때문에 그보다 큰 데이터는 메모리에 올리지 못 하기 때문에 LE, BE간에 차이가 없다. 

---

## 문자열
- ascii: 1 byte
- multi byte: 2 byte
- UTF8: 1 ~ 4 byte
- UTF16: 2 byte
- UTF32: 4 byte

문자열의 경우에도 System에 따라 Endian의 순서에 영향을 받는다. 만약 서로 다른 시스템간에 주고 받는 과정에서 Endian이 맞지 않는 경우 문자 깨짐 현상이 발생한다.
UTF8의 가변 문자 방식으로 시스템의 Endian과 무관하고 동일하게 사용할 수 있는 장점이 있다.


---

## UTF8의 문제점
- 문자열을 10번째 문자까지 자르는 경우
- 버퍼가 25바이트인 경우 몇 문자까지 저장 가능한지 확인하는 경우

가변 문자열의 경우 정확한 길이를 알 수가 없다. 그에 반해 다른 방식의 경우 정확히 계산할 수 있기 때문에 빠르게 처리를 할 수가 있다.

---

## 문자열 전송
- A System: UTF16 LE
- B System: UTF32 LE

```
UTF16 LE -> UTF16BE --전송--> UTF16LE -> UTF32LE
UTF16 LE -> UTF16BE --전송--> UTF32 BE인가? -> 문자깨짐
```
UTF16, UTF32을 전송하게 되면 BE로 변환을 해야하며 받는 쪽에서도 어느 방식인지를 알아야 정확하게 변환을 할 수가 있다.

## 안전한 문자열 전송
- 모든 문자열은 UTF8로 전송
- 디스크에 저장하는 경우에도 UTF8로 저장
- LE, BE양쪽에서 변환 없이 사용이 가능하다

```
UTF16 LE -> UTF8 -> UTF32 LE
```
최소한의 변환으로 문자열 전송이 가능하다


---

## Database의 문자열 타입
- char
- varchar
- nvarchar
- text
- clob
- bpchar

문자열값을 어떻게 저장할지를 나타내는 것이며 문자열 타입이라는 것에는 변함이 없다

---

## Database의 타입과 메모리의 값이 동일하지는 않다

- DB에서 데이터를 저장하는 방식
- DB에서 메모리에 올리는 방식
- DB에서 클라이언트로 전송하는 방식
- 클라이언트가 수신 받은 데이터를 메모리에 올리는 방식

위 방식에 의해서 값은 계속해서 변환된다

## 숫자의 경우

```
4 byte LE -> 4b BE --전송--> 4b BE -> 4b LE
```

---

## Oracle Number 타입
- 22 bytes
- 1 byte (음양) + 1 byte (지수) + 20 bytes (버퍼)
- 64비트 (8byte)에 넣을 수 없는 크기이다
- 데이터의 꺼내면 8 바이트이하는 숫자로 나온다
- 그 이상에서는 UTF8 문자열로 처리한다
- DB의 타입과 조회한 데이터의 타입은 별도로 생각해야 한다





